

// Wallet seed: 8dd96c613b92a1ced03ac5e71a039d4447cfe84928864fc38260b28cd30378c2
import express from 'express';
import { createInterface, type Interface } from 'node:readline/promises';
import { stdin as input, stdout as output } from 'node:process';
import { WebSocket } from 'ws';
import { webcrypto } from 'crypto';
import {
  type BBoardProviders,
  BBoardAPI,
  utils,
  type BBoardDerivedState,
  type DeployedBBoardContract,
  type PrivateStateId,
  bboardPrivateStateKey,
} from '../../api/src/index';
import { ledger, type Ledger, State, PublicState } from '../../contract/src/managed/bboard/contract/index.cjs';
import {
  type BalancedTransaction,
  createBalancedTx,
  type MidnightProvider,
  type UnbalancedTransaction,
  type WalletProvider,
} from '@midnight-ntwrk/midnight-js-types';
import { type Wallet } from '@midnight-ntwrk/wallet-api';
import * as Rx from 'rxjs';
import { type CoinInfo, nativeToken, Transaction, type TransactionId } from '@midnight-ntwrk/ledger';
import { Transaction as ZswapTransaction } from '@midnight-ntwrk/zswap';
import { NodeZkConfigProvider } from '@midnight-ntwrk/midnight-js-node-zk-config-provider';
import { type Resource, WalletBuilder } from '@midnight-ntwrk/wallet';
import { indexerPublicDataProvider } from '@midnight-ntwrk/midnight-js-indexer-public-data-provider';
import { httpClientProofProvider } from '@midnight-ntwrk/midnight-js-http-client-proof-provider';
import { type Logger } from 'pino';
import { type Config, StandaloneConfig } from './config.js';
import type { StartedDockerComposeEnvironment, DockerComposeEnvironment } from 'testcontainers';
import { levelPrivateStateProvider } from '@midnight-ntwrk/midnight-js-level-private-state-provider';
import { type ContractAddress } from '@midnight-ntwrk/compact-runtime';
import { toHex, assertIsContractAddress } from '@midnight-ntwrk/midnight-js-utils';
import { getLedgerNetworkId, getZswapNetworkId } from '@midnight-ntwrk/midnight-js-network-id';

// @ts-expect-error: It's needed to enable WebSocket usage through apollo
globalThis.WebSocket = WebSocket;

/* **********************************************************************
 * getBBoardLedgerState: a helper that queries the current state of
 * the data on the ledger, for a specific bulletin board contract.
 * Note that the Ledger type returned here is not some generic,
 * abstract ledger object, but specifically the type generated by
 * the Compact compiler to correspond to the ledger declaration
 * in the bulletin board contract.
 */

export const getBBoardLedgerState = async (
  providers: BBoardProviders,
  contractAddress: ContractAddress,
): Promise<Ledger | null> => {
  assertIsContractAddress(contractAddress);
  const contractState = await providers.publicDataProvider.queryContractState(contractAddress);
  return contractState != null ? ledger(contractState.data) : null;
};
// providers.publicDataProvider
//   .queryContractState(contractAddress)
//   .then((contractState) => (contractState != null ? ledger(contractState.data) : null));

/* **********************************************************************
 * deployOrJoin: returns a contract, by prompting the user about
 * whether to deploy a new one or join an existing one and then
 * calling the appropriate helper.
 */



///////////////////server/////////////////777



/* **********************************************************************
 * startAPIServer: starts an Express server that provides API endpoints
 * for creating bulletin board contracts
 */
const startAPIServer = async (config: Config, logger: Logger): Promise<void> => {
  const app = express();
  const PORT = process.env.PORT || 3000;
  
  // Middleware
  app.use(express.json());
  
  // Set network ID
  config.setNetworkId();
  
  let serverWallet: (Wallet & Resource) | null = null;
  let serverProviders: BBoardProviders | null = null;
  
  // Initialize wallet and providers for the server
  const initializeServerComponents = async (): Promise<void> => {
    try {
      logger.info('Initializing server wallet and providers...');
      
      // Use your testnet wallet seed
      const TESTNET_WALLET_SEED = 'address';
      
      // Build wallet using the existing function
      serverWallet = await buildWalletAndWaitForFunds(config, logger, TESTNET_WALLET_SEED);
      
      // Create wallet and midnight provider
      const walletAndMidnightProvider = await createWalletAndMidnightProvider(serverWallet);
      
      // Initialize providers using the same pattern as in the run function
      serverProviders = {
        privateStateProvider: levelPrivateStateProvider<PrivateStateId>({
          privateStateStoreName: config.privateStateStoreName,
        }),
        publicDataProvider: indexerPublicDataProvider(config.indexer, config.indexerWS),
        zkConfigProvider: new NodeZkConfigProvider<'post' | 'takeDown' | 'updateTitle' | 'updateDescription' | 'setPrivateWeb'>(config.zkConfigPath),
        proofProvider: httpClientProofProvider(config.proofServer),
        walletProvider: walletAndMidnightProvider,
        midnightProvider: walletAndMidnightProvider,
      };
      
      logger.info('Server wallet and providers initialized successfully');
    } catch (error) {
      logger.error(`Failed to initialize server components: ${error instanceof Error ? error.message : 'Unknown error'}`);
      throw error;
    }
  };

  // API Routes
  
  /**
   * POST /generateNewPageContract
   * Creates a new bulletin board contract and returns the contract address
   */
  app.post('/generateNewPageContract', async (req, res) => {
    try {
      if (!serverProviders) {
        return res.status(500).json({ 
          error: 'Server not initialized. Providers are not available.' 
        });
      }

      logger.info('API: Creating new bulletin board contract...');
      
      // Deploy new contract using the BBoardAPI
      const api = await BBoardAPI.deploy(serverProviders, logger);
      
      const contractAddress = api.deployedContractAddress;
      logger.info(`API: Successfully deployed contract at address: ${contractAddress}`);
      
      // Return the contract address
      res.json({
        success: true,
        contractAddress: contractAddress,
        message: 'New bulletin board contract created successfully'
      });
      
    } catch (error) {
      logger.error(`API: Error creating new contract: ${error instanceof Error ? error.message : 'Unknown error'}`);
      res.status(500).json({
        success: false,
        error: 'Failed to create new contract',
        details: error instanceof Error ? error.message : 'Unknown error'
      });
    }
  });

  /**
   * POST /setValuesPage
   * Joins an existing contract and sets title, description, and message values
   */
  app.post('/setValuesPage', async (req, res) => {
    try {
      if (!serverProviders) {
        return res.status(500).json({ 
          error: 'Server not initialized. Providers are not available.' 
        });
      }

      const { address, title, description, message } = req.body;
      
      // Validate required fields
      if (!address || typeof address !== 'string') {
        return res.status(400).json({
          error: 'Address is required and must be a string'
        });
      }
      
      if (!title || typeof title !== 'string') {
        return res.status(400).json({
          error: 'Title is required and must be a string'
        });
      }
      
      if (!description || typeof description !== 'string') {
        return res.status(400).json({
          error: 'Description is required and must be a string'
        });
      }
      
      if (!message || typeof message !== 'string') {
        return res.status(400).json({
          error: 'Message is required and must be a string'
        });
      }

      logger.info(`API: Setting values for contract at address: ${address}`);
      
      // Clean and validate the contract address format
      const cleanAddress = address.trim();
      if (!cleanAddress.match(/^(0x)?[0-9a-fA-F]+$/)) {
        return res.status(400).json({
          error: 'Invalid contract address format'
        });
      }
      
      // Ensure the address has proper formatting
      const formattedAddress = cleanAddress.startsWith('0x') ? cleanAddress : `${cleanAddress}`;
      
      try {
        // Validate using assertIsContractAddress
        assertIsContractAddress(formattedAddress);
      } catch (error) {
        return res.status(400).json({
          error: 'Invalid contract address'
        });
      }
      
      // Join the existing contract
      const api = await BBoardAPI.join(serverProviders, formattedAddress, logger);
      logger.info(`API: Successfully joined contract at address: ${formattedAddress}`);
      
      // Post the message first
      await api.post(message);
      logger.info(`API: Posted message to contract`);
      
      // Update title and description
      await api.updateTitle(title);
      logger.info(`API: Updated title for contract`);
      
      await api.updateDescription(description);
      logger.info(`API: Updated description for contract`);
      
      logger.info(`API: Successfully set all values for contract ${formattedAddress}`);
      
      // Return success response
      res.json({
        success: true,
        contractAddress: formattedAddress,
        message: 'Contract values updated successfully',
        values: {
          title: title,
          description: description,
          message: message
        }
      });
      
    } catch (error) {
      logger.error(`API: Error setting contract values: ${error instanceof Error ? error.message : 'Unknown error'}`);
      res.status(500).json({
        success: false,
        error: 'Failed to set contract values',
        details: error instanceof Error ? error.message : 'Unknown error'
      });
    }
  });


  /**
   * POST /getWebPage
   * Gets the message from a bulletin board contract's public state
   */
  app.post('/getWebPage', async (req, res) => {
    try {
      if (!serverProviders) {
        return res.status(500).json({ 
          error: 'Server not initialized. Providers are not available.' 
        });
      }

      const { address } = req.body;
      
      if (!address || typeof address !== 'string') {
        return res.status(400).json({
          error: 'Address is required and must be a string'
        });
      }

      logger.info(`API: Getting web page for contract address: ${address}`);
      
      // Clean and validate the contract address format
      const cleanAddress = address.trim();
      if (!cleanAddress.match(/^(0x)?[0-9a-fA-F]+$/)) {
        return res.json({
          error: 'Could not find that address'
        });
      }
      
      // Ensure the address has proper formatting
      const formattedAddress = cleanAddress.startsWith('0x') ? cleanAddress : `${cleanAddress}`;
      
      try {
        // Validate using assertIsContractAddress
        assertIsContractAddress(formattedAddress);
      } catch (error) {
        return res.status(500).json({
          error: 'Could not find that address'
        });
      }
      
      // Get the ledger state for this contract
      const ledgerState = await getBBoardLedgerState(serverProviders, formattedAddress as ContractAddress);
      
      if (ledgerState === null) {
        return res.status(400).json({
          error: 'Could not find that address'
        });
      }
      
      // Extract the message from the ledger state
      const message = !ledgerState.message.is_some ? '' : ledgerState.message.value;
      
      logger.info(`API: Successfully retrieved message for contract ${formattedAddress}`);
      
      // Return just the message
      res.json({
        success: true,
        message: message
      });
      
    } catch (error) {
      logger.error(`API: Error getting web page: ${error instanceof Error ? error.message : 'Unknown error'}`);
      res.status(500).json({
        error: 'Could not find that address'
      });
    }
  });



  /**
   * GET /health
   * Health check endpoint
   */
  app.get('/health', (req, res) => {
    res.json({
      status: 'ok',
      timestamp: new Date().toISOString(),
      walletInitialized: serverWallet !== null,
      providersInitialized: serverProviders !== null
    });
  });
  
  // Initialize components before starting server
  await initializeServerComponents();
  
  // Start the server
  app.listen(PORT, () => {
    logger.info(`BBBoard API Server running on port ${PORT}`);
    logger.info(`Health check: http://localhost:${PORT}/health`);
    logger.info(`Create contract: POST http://localhost:${PORT}/generateNewPageContract`);
  });

  
  
  // Graceful shutdown handling
  const gracefulShutdown = async () => {
    logger.info('API Server: Shutting down gracefully...');
    if (serverWallet) {
      await serverWallet.close();
    }
  };
  
  process.on('SIGTERM', gracefulShutdown);
  process.on('SIGINT', gracefulShutdown);
};




////////////////////////////////server/////////////////////777
const DEPLOY_OR_JOIN_QUESTION = `
You can do one of the following:
  1. Deploy a new bulletin board contract
  2. Join an existing bulletin board contract
  3. Exit
  4. Delete all keys
  5. Add private state with key
Which would you like to do? `;

const deployOrJoin = async (providers: BBoardProviders, rli: Interface, logger: Logger): Promise<BBoardAPI | null> => {
  let api: BBoardAPI | null = null;

  while (true) {
    const choice = await rli.question(DEPLOY_OR_JOIN_QUESTION);
    switch (choice) {
      case '1':
        api = await BBoardAPI.deploy(providers, logger);
        logger.info(`Deployed contract at address: ${api.deployedContractAddress}`);
        return api;
      case '2':
        api = await BBoardAPI.join(providers, await rli.question('What is the contract address (in hex)? '), logger);
        logger.info(`Joined contract at address: ${api.deployedContractAddress}`);
        return api;
      case '3':
        logger.info('Exiting...');
        return null;
      case '4':
        await providers.privateStateProvider.clear();
        await providers.privateStateProvider.clearSigningKeys();
        logger.info("Deleting private state");
        break;
      case '5':
        await addPrivateStateWithKey(providers, rli, logger);
        break;
      default:
        logger.error(`Invalid choice: ${choice}`);
    }
  }
};

/**
 * addPrivateStateWithKey: Helper function to add private state with a secret key
 */
const addPrivateStateWithKey = async (providers: BBoardProviders, rli: Interface, logger: Logger): Promise<void> => {
  try {
    const secretKeyInput = await rli.question('Enter the secret key (32 bytes in hex format): ');
    
    // Validate the secret key format
    if (!secretKeyInput.match(/^(0x)?[0-9a-fA-F]{64}$/)) {
      logger.error('Invalid secret key format. Please provide a 32-byte hex string (64 hex characters).');
      return;
    }

    // Remove '0x' prefix if present and convert to Uint8Array
    const cleanHex = secretKeyInput.replace(/^0x/, '');
    const secretKeyBytes = new Uint8Array(
      cleanHex.match(/.{1,2}/g)?.map(byte => parseInt(byte, 16)) || []
    );

    // Create the private state object
    const privateState = {
      secretKey: secretKeyBytes
    };

    // Store the private state
    await providers.privateStateProvider.set(bboardPrivateStateKey, privateState);
    
    logger.info('Private state successfully added.');
    
  } catch (error) {
    logger.error(`Failed to add private state: ${error instanceof Error ? error.message : 'Unknown error'}`);
  }
};
/* **********************************************************************
 * displayLedgerState: shows the values of each of the fields declared
 * by the contract to be in the ledger state of the bulletin board.
 */
const displayLedgerState = async (
  providers: BBoardProviders,
  deployedBBoardContract: DeployedBBoardContract,
  logger: Logger,
): Promise<void> => {
  const contractAddress = deployedBBoardContract.deployTxData.public.contractAddress;
  const ledgerState = await getBBoardLedgerState(providers, contractAddress);
  if (ledgerState === null) {
    logger.info(`There is no bulletin board contract deployed at ${contractAddress}`);
  } else {
    const boardState = ledgerState.state === State.OCCUPIED ? 'occupied' : 'vacant';
    const latestMessage = !ledgerState.message.is_some ? 'none' : ledgerState.message.value;
    const latestTitle = !ledgerState.title.is_some ? 'none' : ledgerState.title.value;
    const latestDescription = !ledgerState.description.is_some ? 'none' : ledgerState.description.value;
    // NEW FIELDS:
    const publicState = ledgerState.isPublic === PublicState.TRUE ? 'public' : 'private';
    const latestPrivateWeb = !ledgerState.privateWeb.is_some ? 'none' : ledgerState.privateWeb.value;
    
    logger.info(`Current state is: '${boardState}'`);
    logger.info(`Current title is: '${latestTitle}'`);
    logger.info(`Current description is: '${latestDescription}'`);
    logger.info(`Current message is: '${latestMessage}'`);
    logger.info(`Current public state is: '${publicState}'`);
    logger.info(`Current private web is: '${latestPrivateWeb}'`);
    logger.info(`Current sequence is: ${ledgerState.sequence}`);
    logger.info(`Current owner is: '${toHex(ledgerState.owner)}'`);
  }
};


/* **********************************************************************
 * displayPrivateState: shows the hex-formatted value of the secret key.
 */

const displayPrivateState = async (providers: BBoardProviders, logger: Logger): Promise<void> => {
  const privateState = await providers.privateStateProvider.get(bboardPrivateStateKey);
  if (privateState === null) {
    logger.info(`There is no existing bulletin board private state`);
  } else {
    logger.info(`Current secret key is: ${toHex(privateState.secretKey)}`);
  }
};

/* **********************************************************************
 * displayDerivedState: shows the values of derived state which is made
 * by combining the ledger state with private state. In this example, the
 * derived state compares the owner's key with the private secret key to
 * determine if the current user is the owner of the current message.
 */
const displayDerivedState = (ledgerState: BBoardDerivedState | undefined, logger: Logger) => {
  if (ledgerState === undefined) {
    logger.info(`No bulletin board state currently available`);
  } else {
    const boardState = ledgerState.state === State.OCCUPIED ? 'occupied' : 'vacant';
    const latestMessage = ledgerState.state === State.OCCUPIED ? ledgerState.message : 'none';
    const latestTitle = ledgerState.state === State.OCCUPIED ? ledgerState.title : 'none';
    const latestDescription = ledgerState.state === State.OCCUPIED ? ledgerState.description : 'none';
    // NEW FIELDS:
    const publicState = ledgerState.isPublic === PublicState.TRUE ? 'public' : 'private';
    const latestPrivateWeb = ledgerState.state === State.OCCUPIED ? ledgerState.privateWeb || 'none' : 'none';
    
    logger.info(`Current state is: '${boardState}'`);
    logger.info(`Current title is: '${latestTitle}'`);
    logger.info(`Current description is: '${latestDescription}'`);
    logger.info(`Current message is: '${latestMessage}'`);
    logger.info(`Current public state is: '${publicState}'`);
    logger.info(`Current private web is: '${latestPrivateWeb}'`);
    logger.info(`Current sequence is: ${ledgerState.sequence}`);
    logger.info(`Current owner is: '${ledgerState.isOwner ? 'you' : 'not you'}'`);
  }
};

/* **********************************************************************
 * encryptData: encrypts data using AES-GCM with the provided key
 */
const encryptData = async (data: string, key: Uint8Array): Promise<string> => {
  const encoder = new TextEncoder();
  const dataBytes = encoder.encode(data);
  
  // Import the key for AES-GCM
  const cryptoKey = await webcrypto.subtle.importKey(
    'raw',
    key,
    { name: 'AES-GCM' },
    false,
    ['encrypt']
  );
  
  // Generate a random IV
  const iv = webcrypto.getRandomValues(new Uint8Array(12));
  
  // Encrypt the data
  const encrypted = await webcrypto.subtle.encrypt(
    { name: 'AES-GCM', iv },
    cryptoKey,
    dataBytes
  );
  
  // Combine IV and encrypted data, then encode as base64
  const combined = new Uint8Array(iv.length + encrypted.byteLength);
  combined.set(iv);
  combined.set(new Uint8Array(encrypted), iv.length);
  
  return Buffer.from(combined).toString('base64');
};

/* **********************************************************************
 * decryptData: decrypts data using AES-GCM with the provided key
 */
const decryptData = async (encryptedData: string, key: Uint8Array): Promise<string> => {
  try {
    const combined = Buffer.from(encryptedData, 'base64');
    
    // Extract IV (first 12 bytes) and encrypted data
    const iv = combined.slice(0, 12);
    const encrypted = combined.slice(12);
    
    // Import the key for AES-GCM
    const cryptoKey = await webcrypto.subtle.importKey(
      'raw',
      key,
      { name: 'AES-GCM' },
      false,
      ['decrypt']
    );
    
    // Decrypt the data
    const decrypted = await webcrypto.subtle.decrypt(
      { name: 'AES-GCM', iv },
      cryptoKey,
      encrypted
    );
    
    const decoder = new TextDecoder();
    return decoder.decode(decrypted);
  } catch (error) {
    return '[Unable to decrypt - invalid key or corrupted data]';
  }
};



/* **********************************************************************
 * mainLoop: the main interactive menu of the bulletin board CLI.
 * Before starting the loop, the user is prompted to deploy a new
 * contract or join an existing one.
 */
const MAIN_LOOP_QUESTION = `
You can do one of the following:
  1. Post a message
  2. Take down your message
  3. Update title
  4. Update description
  5. Set private web content
  6. Display the current ledger state (known by everyone)
  7. Display the current private state (known only to this DApp instance)
  8. Display the current derived state (known only to this DApp instance)
  9. Exit
  10. Query specific address public ledger
Which would you like to do? `;

const mainLoop = async (providers: BBoardProviders, rli: Interface, logger: Logger): Promise<void> => {
  const bboardApi = await deployOrJoin(providers, rli, logger);
  if (bboardApi === null) {
    return;
  }
  let currentState: BBoardDerivedState | undefined;
  const stateObserver = {
    next: (state: BBoardDerivedState) => (currentState = state),
  };
  const subscription = bboardApi.state$.subscribe(stateObserver);
  try {
    while (true) {
      const choice = await rli.question(MAIN_LOOP_QUESTION);
      switch (choice) {
        case '1': {
          const title = await rli.question(`What title do you want to post? `);
          const description = await rli.question(`What description do you want to post? `);
          const message = await rli.question(`What message do you want to post? `);
          await bboardApi.post(message);
          // After posting the message, update title and description
          await bboardApi.updateTitle(title);
          await bboardApi.updateDescription(description);
          break;
        }
        case '2':
          await bboardApi.takeDown();
          break;
        case '3': {
          const newTitle = await rli.question(`What is the new title? `);
          await bboardApi.updateTitle(newTitle);
          break;
        }
        case '4': {
          const newDescription = await rli.question(`What is the new description? `);
          await bboardApi.updateDescription(newDescription);
          break;
        }
        case '5': {
          // First check if user is the owner
          if (!currentState || !currentState.isOwner) {
            logger.error('You must be the owner of the current post to set private web content.');
            break;
          }
          
          // Check if board is occupied
          if (!currentState || currentState.state !== State.OCCUPIED) {
            logger.error('Cannot set private web content on an empty board.');
            break;
          }
          
          try {
            // Get the private state to access the secret key (same pattern as displayPrivateState)
            const privateState = await providers.privateStateProvider.get(bboardPrivateStateKey);
            if (privateState === null) {
              logger.error('No private state found. Cannot encrypt private web content.');
              break;
            }
            
            const privateWeb = await rli.question(`What private web content do you want to set? `);
            const newMessage = await rli.question(`What new message do you want to set? `);
            
            // Encrypt the private web content using the secret key
            const encryptedPrivateWeb = await encryptData(privateWeb, privateState.secretKey);
            
            logger.info('Encrypting private web content...');
            
            // Send the encrypted content to the contract
            await bboardApi.setPrivateWeb(encryptedPrivateWeb, newMessage);
            
            logger.info('Private web content set successfully (encrypted).');
            
          } catch (error) {
            logger.error(`Failed to set private web content: ${error instanceof Error ? error.message : 'Unknown error'}`);
          }
          break;
        }
        case '6':
          await displayLedgerState(providers, bboardApi.deployedContract, logger);
          break;
        case '7':
          await displayPrivateState(providers, logger);
          break;
        case '8':
          displayDerivedState(currentState, logger);
          break;
        case '9':
          logger.info('Exiting...');
          return;
        case '10': {
          try {
            const contractAddress = await rli.question('Enter the contract address to query (in hex): ');
            
            // Clean and validate the contract address format
            const cleanAddress = contractAddress.trim();
            if (!cleanAddress.match(/^(0x)?[0-9a-fA-F]+$/)) {
              logger.error('Invalid contract address format. Please provide a valid hex address.');
              break;
            }
            
            // Ensure the address has proper formatting - always add 0x prefix
            const formattedAddress = cleanAddress.startsWith('0x') ? cleanAddress : `${cleanAddress}`;
            
            logger.info(`Querying ledger state for contract address: ${formattedAddress}`);
            
            // Validate using assertIsContractAddress before calling getBBoardLedgerState
            try {
              assertIsContractAddress(formattedAddress);
            } catch (error) {
              logger.error(`Invalid contract address: ${formattedAddress}`);
              break;
            }
            
            // Use the existing getBBoardLedgerState function with the validated address
            const ledgerState = await getBBoardLedgerState(providers, formattedAddress as ContractAddress);
            
            if (ledgerState === null) {
              logger.info(`No bulletin board contract found at address ${formattedAddress}`);
            } else {
              const boardState = ledgerState.state === State.OCCUPIED ? 'occupied' : 'vacant';
              const latestMessage = !ledgerState.message.is_some ? 'none' : ledgerState.message.value;
              const latestTitle = !ledgerState.title.is_some ? 'none' : ledgerState.title.value;
              const latestDescription = !ledgerState.description.is_some ? 'none' : ledgerState.description.value;
              const publicState = ledgerState.isPublic === PublicState.TRUE ? 'public' : 'private';
              const latestPrivateWeb = !ledgerState.privateWeb.is_some ? 'none' : ledgerState.privateWeb.value;
              
              logger.info(`=== Ledger State for ${formattedAddress} ===`);
              logger.info(`Current state is: '${boardState}'`);
              logger.info(`Current title is: '${latestTitle}'`);
              logger.info(`Current description is: '${latestDescription}'`);
              logger.info(`Current message is: '${latestMessage}'`);
              logger.info(`Current public state is: '${publicState}'`);
              logger.info(`Current private web is: '${latestPrivateWeb}'`);
              logger.info(`Current sequence is: ${ledgerState.sequence}`);
              logger.info(`Current owner is: '${toHex(ledgerState.owner)}'`);
              
              // If there's private web content and we have a private state, try to decrypt it
              if (latestPrivateWeb !== 'none') {
                try {
                  const privateState = await providers.privateStateProvider.get(bboardPrivateStateKey);
                  if (privateState !== null) {
                    const decryptedPrivateWeb = await decryptData(latestPrivateWeb, privateState.secretKey);
                    logger.info(`Decrypted private web content: '${decryptedPrivateWeb}'`);
                  } else {
                    logger.info(`Private web content is encrypted (no decryption key available)`);
                  }
                } catch (error) {
                  logger.info(`Private web content is encrypted (decryption failed)`);
                }
              }
            }
            
          } catch (error) {
            logger.error(`Failed to query contract address: ${error instanceof Error ? error.message : 'Unknown error'}`);
          }
          break;
        }
        default:
          logger.error(`Invalid choice: ${choice}`);
      }
    }
  } finally {
    // While we allow errors to bubble up to the 'run' function, we will always need to dispose of the state
    // subscription when we exit.
    subscription.unsubscribe();
  }
};

/* **********************************************************************
 * createWalletAndMidnightProvider: returns an object that
 * satifies both the WalletProvider and MidnightProvider
 * interfaces, both implemented in terms of the given wallet.
 */

const createWalletAndMidnightProvider = async (wallet: Wallet): Promise<WalletProvider & MidnightProvider> => {
  const state = await Rx.firstValueFrom(wallet.state());
  return {
    coinPublicKey: state.coinPublicKey,
    encryptionPublicKey: state.encryptionPublicKey,
    balanceTx(tx: UnbalancedTransaction, newCoins: CoinInfo[]): Promise<BalancedTransaction> {
      return wallet
        .balanceTransaction(
          ZswapTransaction.deserialize(tx.serialize(getLedgerNetworkId()), getZswapNetworkId()),
          newCoins,
        )
        .then((tx) => wallet.proveTransaction(tx))
        .then((zswapTx) => Transaction.deserialize(zswapTx.serialize(getZswapNetworkId()), getLedgerNetworkId()))
        .then(createBalancedTx);
    },
    submitTx(tx: BalancedTransaction): Promise<TransactionId> {
      return wallet.submitTransaction(tx);
    },
  };
};

/* **********************************************************************
 * waitForFunds: wait for tokens to appear in a wallet.
 *
 * This is an interesting example of watching the stream of states
 * coming from the pub-sub indexer.  It watches both
 *  1. how close the state is to present reality and
 *  2. the balance held by the wallet.
 */

const waitForFunds = (wallet: Wallet, logger: Logger) =>
  Rx.firstValueFrom(
    wallet.state().pipe(
      Rx.throttleTime(10_000),
      Rx.tap((state) => {
        const scanned = state.syncProgress?.synced ?? 0n;
        const behind = state.syncProgress?.lag.applyGap.toString() ?? 'unknown number';
        logger.info(`Wallet processed ${scanned} indices, remaining ${behind}`);
      }),
      Rx.filter((state) => {
        // Let's allow progress only if wallet is close enough
        const synced = typeof state.syncProgress?.synced === 'bigint' ? state.syncProgress.synced : 0n;
        const total = typeof state.syncProgress?.lag?.applyGap === 'bigint' ? state.syncProgress.lag.applyGap : 1_000n;
        return total - synced < 100n;
      }),
      Rx.map((s) => s.balances[nativeToken()] ?? 0n),
      Rx.filter((balance) => balance > 0n),
    ),
  );

/* **********************************************************************
 * buildWalletAndWaitForFunds: the main function that creates a wallet
 * and waits for tokens to appear in it.  The various "buildWallet"
 * functions all arrive here after collecting information for the
 * arguments.
 */

const buildWalletAndWaitForFunds = async (
  { indexer, indexerWS, node, proofServer }: Config,
  logger: Logger,
  seed: string,
): Promise<Wallet & Resource> => {
  const wallet = await WalletBuilder.buildFromSeed(
    indexer,
    indexerWS,
    proofServer,
    node,
    seed,
    getZswapNetworkId(),
    'warn',
  );
  wallet.start();
  const state = await Rx.firstValueFrom(wallet.state());
  logger.info(`Your wallet seed is: ${seed}`);
  logger.info(`Your wallet address is: ${state.address}`);
  let balance = state.balances[nativeToken()];
  if (balance === undefined || balance === 0n) {
    logger.info(`Your wallet balance is: 0`);
    logger.info(`Waiting to receive tokens...`);
    balance = await waitForFunds(wallet, logger);
  }
  logger.info(`Your wallet balance is: ${balance}`);
  return wallet;
};

// Generate a random see and create the wallet with that.
const buildFreshWallet = async (config: Config, logger: Logger): Promise<Wallet & Resource> =>
  await buildWalletAndWaitForFunds(config, logger, toHex(utils.randomBytes(32)));

// Prompt for a seed and create the wallet with that.
const buildWalletFromSeed = async (config: Config, rli: Interface, logger: Logger): Promise<Wallet & Resource> => {
  const seed = await rli.question('Enter your wallet seed: ');
  return await buildWalletAndWaitForFunds(config, logger, seed);
};

/* ***********************************************************************
 * This seed gives access to tokens minted in the genesis block of a local development node - only
 * used in standalone networks to build a wallet with initial funds.
 */
const GENESIS_MINT_WALLET_SEED = '0000000000000000000000000000000000000000000000000000000000000001';

/* **********************************************************************
 * buildWallet: unless running in a standalone (offline) mode,
 * prompt the user to tell us whether to create a new wallet
 * or recreate one from a prior seed.
 */

const WALLET_LOOP_QUESTION = `
You can do one of the following:
  1. Build a fresh wallet
  2. Build wallet from a seed
  3. Exit
Which would you like to do? `;

const buildWallet = async (config: Config, rli: Interface, logger: Logger): Promise<(Wallet & Resource) | null> => {
  if (config instanceof StandaloneConfig) {
    return await buildWalletAndWaitForFunds(config, logger, GENESIS_MINT_WALLET_SEED);
  }
  while (true) {
    const choice = await rli.question(WALLET_LOOP_QUESTION);
    switch (choice) {
      case '1':
        return await buildFreshWallet(config, logger);
      case '2':
        return await buildWalletFromSeed(config, rli, logger);
      case '3':
        logger.info('Exiting...');
        return null;
      default:
        logger.error(`Invalid choice: ${choice}`);
    }
  }
};

const mapContainerPort = (env: StartedDockerComposeEnvironment, url: string, containerName: string) => {
  const mappedUrl = new URL(url);
  const container = env.getContainer(containerName);

  mappedUrl.port = String(container.getFirstMappedPort());

  return mappedUrl.toString().replace(/\/+$/, '');
};

/* **********************************************************************
 * run: the main entry point that starts the whole bulletin board CLI.
 *
 * If called with a Docker environment argument, the application
 * will wait for Docker to be ready before doing anything else.
 */

export const run = async (config: Config, logger: Logger, dockerEnv?: DockerComposeEnvironment): Promise<void> => {
    // Check if we should run in server mode
  const args = process.argv.slice(2);
  const serverMode = args.includes('--server') || args.includes('-s');
  
  if (serverMode) {
    logger.info('Starting in API server mode...');
    await startAPIServer(config, logger);
    return; // Don't continue with CLI mode
  }
  
  
  const rli = createInterface({ input, output, terminal: true });
  let env;
  if (dockerEnv !== undefined) {
    env = await dockerEnv.up();

    if (config instanceof StandaloneConfig) {
      config.indexer = mapContainerPort(env, config.indexer, 'bboard-indexer');
      config.indexerWS = mapContainerPort(env, config.indexerWS, 'bboard-indexer');
      config.node = mapContainerPort(env, config.node, 'bboard-node');
      config.proofServer = mapContainerPort(env, config.proofServer, 'bboard-proof-server');
    }
  }
  const wallet = await buildWallet(config, rli, logger);
  try {
    if (wallet !== null) {
      const walletAndMidnightProvider = await createWalletAndMidnightProvider(wallet);
      const providers = {
        privateStateProvider: levelPrivateStateProvider<PrivateStateId>({
          privateStateStoreName: config.privateStateStoreName,
        }),
        publicDataProvider: indexerPublicDataProvider(config.indexer, config.indexerWS),
        zkConfigProvider: new NodeZkConfigProvider<'post' | 'takeDown' | 'updateTitle' | 'updateDescription' | 'setPrivateWeb'>(config.zkConfigPath),
        proofProvider: httpClientProofProvider(config.proofServer),
        walletProvider: walletAndMidnightProvider,
        midnightProvider: walletAndMidnightProvider,
      };
      await mainLoop(providers, rli, logger);
    }
  } catch (e) {
    logError(logger, e);
    logger.info('Exiting...');
  } finally {
    try {
      rli.close();
      rli.removeAllListeners();
    } catch (e) {
      logError(logger, e);
    } finally {
      try {
        if (wallet !== null) {
          await wallet.close();
        }
      } catch (e) {
        logError(logger, e);
      } finally {
        try {
          if (env !== undefined) {
            await env.down();
            logger.info('Goodbye');
            process.exit(0);
          }
        } catch (e) {
          logError(logger, e);
        }
      }
    }
  }
};

function logError(logger: Logger, e: unknown) {
  if (e instanceof Error) {
    logger.error(`Found error '${e.message}'`);
    logger.debug(`${e.stack}`);
  } else {
    logger.error(`Found error (unknown type)`);
  }
}